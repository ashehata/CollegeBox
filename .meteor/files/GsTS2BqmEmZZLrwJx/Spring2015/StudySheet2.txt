* OS Design
  - Kernel vs Apps
  - kernel / User boundary
  - sys calls
  - structure of OS:

* Types of Kernels
  Monolithic Kernel: Code broken into functions, all functions then linked
    together into a single control program.
  Layered:The main advantage of the layered approach is simplicity of 
    construction and debugging. The layers are selected so that each                                    uses functions (operations) and  
    services of only lower-level layers. This approach simplifies debugging 
    and system verification. The first layer can be debugged without any 
    concern for the rest of the system, because, by definition, it uses only the 
    basic hardware (which is assumed correct) to implement its functions.
  OO: OS is objects with well-defined interfaces. Writen in an object oriented language.
  Microkernel:All new services are added to user space and consequently do 
    not require modification of the kernel. When the kernel does have to be 
    modified, the changes tend to be fewer, because the microkernel is a 
    smaller kernel.
* Virtualization: Uses DRAM as a cache for virtual 
    address space. Each process gets same uniform linear address space. 
    Processes cant interfer with one another and cannot access kernel information.

** Hypervisor
   OS layer for creating containers. The virtual machine simulates the complete 
   hardware, allowing an unmodified OS for a completely different CPU to be run.
*** Problem
    We need another security level, else we have privileged
    instructions.
**** Solutions
     - Standard emulation. Simulate the hardware. Simple, but slow.
     - Type 1. Hardware support. Requires a change to CPU.
     - Type 2. Binary translation. All privileged instructions are
       calls to hypervisor.
     - Paravirtualization: the virtual machine does not simulate hardware 
       but instead offers a special API that requires OS modifications.
     - OS Virtualization. (Popular. Docker / Rocket / LXC)
     - Java/.net vm. Not really virtualization, but meh.
* Processes
** Abstraction
   ???
** Unix
  - fork(): creates child process idetical to parent, but the fork 
    call returns 0 to child process and child's pid to parent process.
  - exec(): 
  - execve(char *filename, char *argv[], char *envp[]): Loads and runs
    executable filename, with argument list argv, and enviroment variable
    list envp ("name=value" strings). 1 call, no return.
  - exit(): exits a process, normally return with status 0.
  - wait(): suspends current process until one of its children terminates.
    return value is the pid of child process terminated. if child_status !=
    NULL, then the object it points to will be the status indicating why
    the process was terminated.
  - waitpid(): suspends current process until specific process terminates.
  - signals / signal handlers : A signal (int 1-30) sent from the kernel to
    a process by updating some state in the contextt of the destination process.
    Ways to react include: ignore, terminate the process (maybe core dump), 
    or the process catches the signal by executing a user-level function called
    a signal handler. The kernel maintains list of pending and blocked signals 
    in the context of each process. ctrl-c sends SIGINT to every job in the
    foreground process group.
** Xinu
   - All programs are in the same address space.
   - Process table
   - Process states
   - Concepts, creation, termination
   - create, resume
   - kill: the command kill(6639) would terminate a process with 
     PID = 6639. 
   - ready, resched
   - ctxsw
        context is a state consisting of:
            - general purpose registers
            - floating-point registers
            - program counter
            - user's stack
            - status registers
            - kernel's stack
            - kernel data structures (ie page, process and file tables)
   - Threads
        - A logical flow, hybrid between a process and I/O multiplexing. 
        - scheduled by kernel like a process
        - shares same virtual address space like I/O flows

* Threads
  What is a thread?

  - Unix / cthreads

  | text             |
  | data             |
  | bss              |
  | heap             |
  | (grows downward) |

  Adding a thread means adding a stack (I think.):

  | pc0, pc1 -> | text                   |
  |             | data                   |
  |             | bss                    |
  |             | heap                   |
  |             | (grows downward)       |
  |             | stack_1 (grows upward) |
  |             | stack_0 (grows upward) |

  Look at threads in xinu.
* Process scheduling
  - Long: decides which jobs/processes are to be admitted to the ready queue.
    Med: removes processes from main memory and places on secondary memory(disk)
    short: decides which of the in-memory processes are to be executed, 
    after a clock interupt, an I/O interupt, and operating system call, or 
    another form of signal.
  - compute bound: program would go faster if cpu were faster (calculate pie)
  - I/O bound: program would go faster if I/O subsystem was faster (read disk)
** Metrics
   Required time, response time, missed time:
P   E |                                                 W   E   E   E||    
R     |    
O   D |                                     W   W   W   D||      
C     |    
E   C |                     W   W   W   W   W   W   C||    
S     |    
S   B |                 W   W   W   B   B   B   B||    
      |    
    A | A   A   A   A   A   A   A||    
      |_________________________________________________________________
       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16
                  	T I M E  =>     
    
TABLE:    
	T = elapsed time (includes waiting)    
	t = processing time required    
	M = T-t = missed (idle) time    
	R = t/T = ratio (response) time    
	P = T/t = penalty rate = 1/R    
    
Arrival  Process    time (t)	elapsed    missed   ratio    Penalty 
time		        required    time (T)    time	
    
0          A	    	7	        7	      0        1       1    
4	       B		    7	        7         3	     4/7     7/4    
5	       C		    1	        7	      6	     1/7       7    
9	       D		    1	        4	      3	     1/4       4    
12	       E		    3	        4	      1	     3/4     4/3    

** Preemptive, non..
   Algorithms: FCFS (first come first serve: high average wait time,), 
               RR (round robin: equal time slices, starvation free), 
               SPN (shortest process next) 
               Multi-level feedback (multiple queues are maintained, 
                    each has its own algorithm)
** Files
   0,1, 2 : stdin, stdout, sterr
   - Descriptor table
        - One table per process. 
        -  dup2(4,1) causes fd=1 to refer to disk file pointed at by fd=4 (file descriptor).
   - Filetables
        - The set of open files shared by all processes. An entry consists
            of the current file position, the number of descriptors pointing
            to it, and a pointer to an entry in the v-node table. 
** Virtual Memory
   - Page tables
        - array of page table entries, has valid bit and address field. 
          If valid bit is 1 then address indicates location in DRAM.
          If valid bit is 0 and address is null then virtual page has 
          not been allocated. If valid bit 0 and address is present then 
          address points to start of virtual page on disk. 
   - Address translation
        - Hardware on CPU chip called memory management unit (MMU) translates
          virtual addresses on the fly, using a look-up table stored in main
          memory which is managed by the OS. 
   - Swap
        - Page fault exception handling: if page fault resulted from a legal 
          operation on legal virtual address, kernel selects victim page to swap 
          out with new page and then updates page table. 
   - Thrashing
        - loading pages in and out of memory continously
   - Locality
        - principle that programs tend to work on a small set of processes
          called working sets.
   -  Working set (see above)
   -  Page hit/ Page fault: reference to VM word that is in DRAM cache or isn't. 


** Network programming
   Addresses, host names, DNS
   CLient server, port number
   IP: basic addressing scheme and unreliable delivery of packets (datagrams).
   Tcp connections sockets: Transmission control protocol. Uses IP to provide
   reliable byte streams from process-to-process over connections.
   connect read write close
   bind listen accept
   gethost by name
   network byte order
   sockaddr
   web protocols
   mail protocols
   - http
    - methods
    - version
    - request/response headers
   - proxies
   header: contains packet size, source and destination addresses. 
   payload: contains data bits sent from source host.

** Synchronization
   mutual exclusion
   - disable/restore
   - spin locks: process waits in a loop until lock is released. 
   - switches
   - semaphores: Abstract data type keeps track of total available resources. 
                 A process calls wait, if semaphore value is not null,
                 value is decremented, otherwise the process is added to 
                 semaphore's queue until the value is greater or equal to 1. 
                 A process calls signal when done with resources, this 
                 incriments semaphore value by 1 and the semaphore gives 
                 resources to next in queue if applicable. 
* setjmp/longjmp: Controlled way to break the procedure call/return discipline.
    First call setjmp(jmp_buf j) to record return site (ie register context, 
    stack pointer, PC value) for longjmp later. Then, if later in the code
    we get an error, we can catch it by calling longjmp(jmp_buf, int i) for some
    i and return to a previous state in the program. A program might use this
    to implement a ctrl-c signal handler. 

virtual scheduling.
chapter 8, 9, 10

device drivers.
 upper half, lower half.
